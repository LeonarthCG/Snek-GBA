//making the header

#define armJump(label) "WORD 0xEA000000 + (((label-currentoffset-8)/4)&0xFFFFFF)"

ORG $0
armJump(romStart) //arm instruction, jump to 0xC0
#incbin "bitmap.bin" //displayed, then checked on bootup, gba hangs without this
BYTE 0x20 0x20 0x20 0x20 0x20 0x20 0x20 0x20 0x20 0x20 0x20 0x20 //uppercase ascii, max 12 characters
BYTE 0x20 0x20 0x20 0x20 //uppercase ascii, 4 characters
BYTE 0x20 0x20 //uppercase ascii, 2 characters
BYTE $96 //fixed value
BYTE 0 //main unit, 0 for gba
BYTE 0 //device type
BYTE 0 0 0 0 0 0 0 //some empty bytes
BYTE 0 //software version
BYTE $A7 //checksum of bytes A0 to BC, ((0 - each byte) - $19 )&0xFF, I should make a tool to calculate it at some point
SHORT 0 //some empty bytes

//the strings for the header
PUSH; ORG $A0; String(DEMO); POP
PUSH; ORG $AC; String(DEMO); POP
PUSH; ORG $B0; String(00); POP

romStart:
#inctext lyn "ASM\boot.elf" //change to thumb and set the background layers, tiles and palettes up

ALIGN 4
titlescreenLoop:
#inctext lyn "ASM\titlescreenLoop.elf" //load the titlescreen and wait for a start press to begin the game

ALIGN 4
mainLoop:
#inctext lyn "ASM\mainLoop.elf" //wait for vblank and execute the gameplay routines

ALIGN 4
interrupt:
#inctext lyn "ASM\interrupt.elf" //change to thumb after waiting for vblank and acknowledge interrupt

ALIGN 4
fadeIn:
#inctext lyn "ASM\fadeIn.elf"

ALIGN 4
fadeOut:
#inctext lyn "ASM\fadeOut.elf"

ALIGN 4
rng:
#inctext lyn "ASM\rng.elf" //get random number, return it in r0 and also set it as the next seed

ALIGN 4
drawTile:
#inctext lyn "ASM\drawTile.elf" //draw tile at given coords and background layer

ALIGN 4
copyBuffers:
#inctext lyn "ASM\copyBuffers.elf" //copy the tilemap buffers over to their destination

ALIGN 4
makeTileAttribute:
#inctext lyn "ASM\makeTileAttribute.elf" //piece together the short for the tile based on the attributes

ALIGN 4
changeSpeed:
#inctext lyn "ASM\changeSpeed.elf" //draws speed option to titlescreen and handles changing between options

ALIGN 4
loadData:
#inctext lyn "ASM\loadData.elf" //load data from source to destination

ALIGN 4
fillDest:
#inctext lyn "ASM\fillDest.elf" //fill destination with given value and size

ALIGN 4
updateScore:
#inctext lyn "ASM\updateScore.elf" //update the SIZE and HIGH SCORE numbers, and save high score if needed

ALIGN 4
startSnake:
#inctext lyn "ASM\Snake\startSnake.elf" //prepare the snake's starting position

ALIGN 4
turnSnake:
#inctext lyn "ASM\Snake\turnSnake.elf" //change the direction the snake is heading towards
//the snake can't change direction to the one she is already facing towards nor the one opposite to it
//button presses are saved each frame, even if the game logic isn't run each frame, and are cleared at the end of this routine
//this allows the player to input a direction for the snake to turn to without having to hold the button down waiting for the game logic
//the snake also can't turn towards the border of the screen if adjacent to it
//in addition, the snake can't turn if doing so is going to make her face her own body immediately

ALIGN 4
moveSnake:
#inctext lyn "ASM\Snake\moveSnake.elf" //check if the snake has grown and move all pieces of the body as needed

ALIGN 4
bonkSnake:
#inctext lyn "ASM\Snake\bonkSnake.elf" //check if the given coords are already occupied by snake, return 1 if it is

ALIGN 4
drawSnake:
#inctext lyn "ASM\Snake\drawSnake.elf" //draw snake according to the positions

ALIGN 4
killSnake:
#inctext lyn "ASM\Snake\killSnake.elf" //make the death animation happen

ALIGN 4
drawSnakeBody:
#inctext lyn "ASM\Snake\drawSnakeBody.elf" //routine that specifically draws the body segments (so not head/tail/tongue)
//the checks got long enough for it to justify a routine
//snake body shapes are the -, the |, the luigi, the waluigi, the mirror luigi and the mirror waluigi, of course

ALIGN 4
makeEgg:
#inctext lyn "ASM\Egg\makeEgg.elf" //spawn egg and write the coords and tile to ram for the drawEgg routine

ALIGN 4
eatEgg:
#inctext lyn "ASM\Egg\eatEgg.elf" //check if head and egg are in the same coords, and if so remove egg and add size to snake

ALIGN 4
drawEgg:
#inctext lyn "ASM\Egg\drawEgg.elf" //draw egg according to the coords and tile in ram

ALIGN 4
makeEggMap:
#inctext lyn "ASM\Egg\makeEggMap.elf" //make the starting map for the egg

ALIGN 4
updateEggMap:
#inctext lyn "ASM\Egg\updateEggMap.elf" //change tiles in egg map according to new head and tail positions

/*
facing directions of the snake:
     1
     ^
     |
0 <- o -> 3
     |
     v
     2
*/

//the snake's longest possible length is 540, so I'm going to limit it to that and cause a game over if it's reched (with a win message?)

ALIGN 4
bgTilemapsBuffer:
WORD $03000000
WORD $03000800
WORD $03001000
WORD $03001800

ALIGN 4
bgTilemaps:
WORD $0600F800
WORD $0600F000
WORD $0600E800
WORD $0600E000

ALIGN 4
speedTSAs:
POIN slowTSA
POIN normalTSA
POIN fastTSA
POIN tasTSA

ALIGN 4
speedSpeeds:
BYTE 16
BYTE 8
BYTE 4
BYTE 1

ALIGN 4
snekIMG:
SHORT 0 440
#incext png2dmp "Graphics\snek.png"

ALIGN 4
snekPAL:
SHORT 0 8
#incext png2dmp "Graphics\snek.png" --palette-only

ALIGN 4
heckIMG:
SHORT 0 64
#incext png2dmp "Graphics\heck.png"

ALIGN 4
heckmirrorIMG:
SHORT 0 64
#incext png2dmp "Graphics\heckmirror.png"

ALIGN 4
titlescreenIMG:
SHORT 0 9600
#incbin "Graphics\titlescreen.img.bin"

ALIGN 4
titlescreenPAL:
SHORT 0 128
#incbin "Graphics\titlescreen.pal.bin"

ALIGN 4
titlescreenTSA:
SHORT 0 320
#incbin "Graphics\titlescreen.tsa.bin"

ALIGN 4
presstartIMG:
SHORT 0 256
#incext png2dmp "Graphics\pressstart.png"

ALIGN 4
speedIMG:
SHORT 0 416
#incext png2dmp "Graphics\speed.png"

ALIGN 4
presstartTSA:
SHORT 0 25
#incbin "Graphics\pressstart.tsa.bin"

ALIGN 4
slowTSA:
SHORT 0 25
#incbin "Graphics\slow.tsa.bin"

ALIGN 4
normalTSA:
SHORT 0 25
#incbin "Graphics\normal.tsa.bin"

ALIGN 4
fastTSA:
SHORT 0 25
#incbin "Graphics\fast.tsa.bin"

ALIGN 4
tasTSA:
SHORT 0 25
#incbin "Graphics\tas.tsa.bin"

ALIGN 4
backgroundgridTSA:
SHORT 0 320
#incbin "Graphics\backgroundgrid.tsa.bin"

ALIGN 4
scoreTSA:
SHORT 0 32
#incbin "Graphics\score.tsa.bin"
